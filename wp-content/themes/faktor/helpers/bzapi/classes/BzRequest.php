<?php
namespace BzApi;

require_once dirname(__FILE__).'/../config/bzapi_config.php';

define('LINE_DELIMITER', chr(1));
define('COLUMN_DELIMITER', chr(2));
define('PARAMETER_DELIMITER', chr(3));
define('COMMAND_DELIMITER', chr(4));
define('KEY_VALUE_OPERATOR', '=>');

/**
 * Class to query the sbzonline API.
 *
 * This class represents the api. The BzClient class is used to abstract from
 * it.
 *
 * If used within Contao, every request gets logged to the system log and another
 * table.
 *
 * @author ds
 *        
 */
class BzRequest
{
	// the supported commands
	const CMD_CREATE_SESSION = 'createSession';
	const CMD_DROP_SESSION = 'dropSession';
	const CMD_GET_SELECTION = 'getSelection';
	const CMD_GET_SELECTIONINFO = 'getSelectioninfo';
	const CMD_ADD_PRIVATECUSTOMER = 'addPrivatecustomer';
	const CMD_ADD_ORDER_BOOKIT = 'addOrderBookit';
	const CMD_ADD_DETAIL_BOOKIT = 'addDetailBookit';
	const CMD_RELEASE_ORDER = 'releaseOrder';

	const PARAM_SESSION = 'session';
	
	// CMD_CREATE_SESSION
	const PARAM_KUERZEL = 'kuerzel'; // string(10)
	const PARAM_PASSWORT = 'passwort'; // string(10)
	const PARAM_CLIENT_ID = 'clientID'; // string(40), opt., may be good for debugging
	const PARAM_CLIENT_VERSION = 'clientVersion'; // string(40), opt., may be good for debugging
	

	// CMD_ADD_PRIVATECUSTOMER
	const PARAM_PRIVATKUNDENNUMMER = 'privatkundennummer'; // numeric(10), unique customer id, opt., defaults to an autogenerated number
	const PARAM_ANREDE = 'anrede'; // string(30), opt., if set to 'Firma', name is the firm name and the first is used as an additional address line
	const PARAM_NAME = 'name'; // string(30), last name oder firm name
	const PARAM_VORNAME = 'vorname'; // string(30), opt., first name or (first?) address line
	const PARAM_ADRESSE = 'adresse'; // 3 rows with 30 chars max, CR/LF and LF as \n, gets wrapped
	const PARAM_PLZ = 'plz'; // numeric(10), zip code
	const PARAM_ORT = 'ort'; // string(30), city
	const PARAM_LAND = 'land'; // enum, opt., defaults to CH
	const PARAM_SPRACHE = 'sprache'; // enum, opt., defaults to german, fr seems not to be available...???
	const PARAM_TRANSAKTION = 'transaktion'; // string(40), opt., used to retrieve info about the transaction, not useful in this command
	const PARAM_SACHGEBIETCODE = 'sachgebietcode'; // string(20), opt., not used
	const PARAM_SACHGEBIETTEXT = 'sachgebiettext'; // string(50), opt., not used
	const RESULT_PRIVATKUNDENNUMMER = 'privatkundennummer'; // numeric(10), customer id
	

	// CMD_ADD_ORDER_BOOKIT
	const PARAM_LIEFERDATUM = 'lieferdatum'; // string(8), format: YYYYMMDD, opt. defaults to next working day
	const PARAM_AUFTRAGSREFERENZ = 'auftragsreferenz'; // string(20), opt., info to print on delivery note/label
	const PARAM_LIEFERADRESSE = 'lieferadresse'; // numeric(10), references privateCustomer
	const PARAM_RECHNUNGSADRESSE = 'rechnungsadresse'; // numeric(10), references privateCustomer, opt. defaults to // PARAM_LIEFERADRESSE
	const PARAM_VARIANTENART = 'variantenart'; //enum, opt. we probalby have only one varianten art and can therefore omit it to use the default
	const PARAM_VERSANDART = 'versandart'; // enum ('Post Economy', 'Post Priority', ...), opt. Economy is default
	const PARAM_ZAHLUNGSART = 'zahlungsart'; // enum ('15 Tage netto', ..., '60 Tage netto', 'Kreditkarte'), opt. '30 // Tage netto' is default
	const PARAM_WAEHRUNGSART = 'waehrungsart'; // enum ('CHF'), opt. 'CHF' is default and the only option
	const PARAM_AUFTRAGSTEXT = 'auftragstext'; // string(128), maximum 4 lines(CR/LF or LF) with 32 chars max, opt., best to let them insert the newlines
	const PARAM_VERSANDSPESEN = 'versandspesen'; // numeric(6.2), opt. delivery charges to be charged on the customers bill
	const PARAM_AUFTRAGSKONTROLLE = 'auftragskontrolle'; // numeric(2), opt., number of minutes to wait before order gets deleted if no releaseOrder arrives..
	/*const PARAM_TRANSAKTION = 'transaktion'; // string(40), opt., transaction number can be used to retrieve info about the whole transaction */
	const RESULT_AUFTRAG = 'auftrag'; //numeric(10), order id
	

	// CMD_ADD_DETAIL_BOOKIT
	const PARAM_AUFTRAG = 'auftrag'; // numeric(10), order id
	const PARAM_ARTIKEL = 'artikel'; // string(255), article id
	const PARAM_MENGE = 'menge'; // numeric(3), amount
	const PARAM_ENDPREIS = 'endpreis'; // numeric(6.2), opt. use to set a price for the customer
	const PARSE_OUTPUT_MODE_TXT = 0;
	const PARSE_OUTPUT_MODE_HTML = 1;
	const PARSE_OUTPUT_MODE_ARRAY = 2;
	
	// used to store the commands as array(strCommand, arrParamters) before
	// executing them
	private $_buffer = array();
	
	// flag to query whether the request has already been issued.
	private $_executed = false;
	
	private $_rawRequestBody = null;
	
	private $_rawResponseBody = null;
	
	private $_resultCache = null;
	
	private $_resultStringCache = '';
	
	private $_issuedAt = null;
	
	private $_completedAt = null;
	
	// with this, we map the chosen shipping option to the bz shipping options
	public static $MAP_VERSANDARTEN = array(
		'CH' => array('A-Post' => 16, 'B-Post' => 10),
		'WORLD' => array('A-Post' => 12, 'B-Post' => 28)
	);

	/**
	 * Add one of the following commands to this request:
	 *
	 * (CreateSession and DropSession are issued automatically)
	 */
	public function addCommand($command, $parameters = null)
	{
		DEBUG && self::log(sprintf('adding [%s, {%s}]', $command, self::array2string($parameters)));
		// check if command and its parameters are valid
		if ($this->checkCommand($command, $parameters))
		{
			$this->_buffer[] = array(
				$command,
				$parameters
			);
			return true;
		}
		return false;
	}

	/**
	 * Execute this request.
	 */
	public function execute()
	{
		// assemble request string form buffer
		$isFirst = true;
		$requestBody = '';
		foreach ($this->_buffer as $arrCommand)
		{
			if (! $isFirst)
			{
				// separate commands
				$this->_rawRequestBody .= COMMAND_DELIMITER;
			}
			$strCommand = $arrCommand[0];
			$arrParameters = $arrCommand[1];
			$strParameters = '';
			if (! is_null($arrParameters) && ! empty($arrParameters))
			{
				foreach ($arrParameters as $key => $value)
				{
					// always add param_delimiter fist, because we always have a
					// command...
					$strParameters .= PARAMETER_DELIMITER . $key . KEY_VALUE_OPERATOR . $value;
				}
			}
			// this is the whole 'line' for this command:
			$this->_rawRequestBody .= $strCommand . $strParameters;
			$isFirst = false;
		}
		
		// var_dump($this->_buffer);die();
		

		// execute HTTP request and collect output
		$ch = curl_init();
		// set request paramters:
		$curlOptions = array(
			CURLOPT_URL            => URL,
			CURLOPT_RETURNTRANSFER => 1,
			CURLOPT_POST           => 1,
			CURLOPT_POSTFIELDS     => utf8_decode($this->_rawRequestBody), // set request content:
			CURLOPT_HTTPHEADER     => array('Content-Type: application/x-www-form-urlencoded'), // always set this header
			CURLOPT_SSL_VERIFYHOST => 0,
			CURLOPT_SSL_VERIFYPEER => 0,
		);
		
		curl_setopt_array($ch, $curlOptions);
		
		// issue request and wait, and measure time for logging
		$this->_issuedAt = microtime(true);
		$answer = curl_exec($ch);
		$this->_completedAt = microtime(true);
		
		$this->_rawResponseBody = utf8_encode($answer);
		
		$this->_executed = true;
		
		// log this request (only if called from within contao
		if (class_exists('BzApi\BzApiRequestLogModel'))
		{
			$log = new BzApiRequestLogModel();
			$log->request = self::parse($this->_rawRequestBody, self::PARSE_OUTPUT_MODE_HTML);
			$log->response = self::parse($this->_rawResponseBody, self::PARSE_OUTPUT_MODE_HTML);
			$log->result = $this->getResultString();
			$log->save();
			
			\System::log(serialize($this->getResult()), 'BzApi', TL_GENERAL);
		}
		// parse returned string
		return $this->getResult();
	}

	public function isOk()
	{
		if ($this->_executed)
		{
			foreach ($this->getResult() as $commandResult)
			{
				if ($commandResult['statusCode'] != 0)
				{
					return false;
				}
			}
			return true;
		}
		else
		{
			return false;
		}
	}

	public function getErrors()
	{
		$errors = array();
		foreach ($this->getResult() as $commandResult)
		{
			if ($commandResult['statusCode'] != 0)
			{
				$errors[$commandResult['command'][0]] = $commandResult['statusMessage'];
			}
		}
		return $errors;
	}

	public function getErrorString()
	{
		$str = '';
		$isFirst = true;
		foreach ($this->getErrors() as $cmd => $error)
		{
			if (! $isFirst)
			{
				$str .= "\n";
			}
			$str .= sprintf('%s: %s', $cmd, $error);
			$isFirst = false;
		}
		return $str;
	}

	public function getResult()
	{
		if (is_null($this->_resultCache) && $this->_executed)
		{
			$result = array();
			$commands = explode(COMMAND_DELIMITER, $this->_rawResponseBody);
			$c = 0;
			foreach ($commands as $command)
			{
				$commandResult = array();
				$temp = explode(PARAMETER_DELIMITER, $command);
				$commandResult['command'] = $this->_buffer[$c];
				$commandResult['statusCode'] = $temp[0];
				$commandResult['statusMessage'] = $temp[1];
				$parameters = array();
				for ($i = 2; $i < count($temp); $i ++)
				{
					if (strpos($temp[$i], LINE_DELIMITER))
					{
						$lines = explode(LINE_DELIMITER, $temp[$i]);
						$arrLines = array();
						foreach ($lines as $l)
						{
							$arrLines[] = explode(COLUMN_DELIMITER, $l);
						}
						$parameters[] = $arrLines;
					}
					else
					{
						$parameters[] = $temp[$i];
					}
				}
				$commandResult['output_parameters'] = $parameters;
				$result[] = $commandResult;
				$this->_buffer[$c]['result'] = $commandResult;
				$c ++;
			}
			$this->_resultCache = $result;
		}
		return $this->_resultCache;
	}
	
	public function getResultString()
	{
		if(empty($this->_resultStringCache))
		{
			$this->_resultStringCache = '<table border="1"><thead><tr><th>Command</th><th>Parameters</th><th>Status Code</th><th>Status Message</th><th>Output Parameters</th></tr></thead>';
			foreach($this->getResult() as $commandResult)
			{
				if(is_array($commandResult['command'][1]))
				{
					$parametersString = '<table>';
					foreach($commandResult['command'][1] as $key => $value)
					{
						$parametersString .= sprintf('<tr><td>%s</td><td>%s</td></tr>', $key, $value);
					}
					$parametersString .= '</table>';
				}
				else
				{
					$parametersString = 'No command parameters';
				}
				
				if(!empty($commandResult['output_parameters']))
				{
					$outputParametersString = '<table>';
					foreach($commandResult['output_parameters'] as $key => $value)
					{
						if(is_array($value))
						{
							$outputParametersString .= sprintf('<tr><td>%s</td><td><pre>%s</pre></td>', $key, print_r($value, true));
						}
						else
						{
							$outputParametersString .= sprintf('<tr><td>%s</td><td>%s</td>', $key, print_r($value, true));
						}
					}
					$outputParametersString .= '</table>';
				}
				else
				{
					$outputParametersString = '';
				}
				$this->_resultStringCache .= sprintf('<tr><td>%s</td><td>%s</td><td>%d</td><td>%s</td><td>%s</td></tr>', 
					$commandResult['command'][0], 
					$parametersString, 
					$commandResult['statusCode'], 
					$commandResult['statusMessage'],
					$outputParametersString
				);
			}
			$startDate = \DateTime::createFromFormat('U.u', $this->_issuedAt);
			$this->_resultStringCache .= sprintf('<tfoot><tr><td colspan="5">Request to "%s" was issued on %s at %s and took %f seconds to complete.</td></tr></tfoot>',
				URL,
				$startDate->format(DATE_FORMAT), 
				$startDate->format(TIME_FORMAT),
				$this->_completedAt - $this->_issuedAt);
			$this->_resultStringCache .= '</table>';
		}
		return $this->_resultStringCache;
	}

	public function getRawRequestBody()
	{
		return $this->_rawRequestBody;
	}

	public function getRawResponseBody()
	{
		return $this->_rawResponseBody;
	}

	public function getRequestBody()
	{
		return self::parse($this->_rawRequestBody);
	}

	public function getResponse()
	{
		return self::parse($this->_rawResponseBody);
	}

	protected function checkCommand(&$command, &$parameters)
	{
		
		// nullify or lowercase all parameter names first
		if (! is_null($parameters))
		{
			if (empty($parameters))
			{
				$parameters = null;
			}
			else
			{
				self::parameter2lower($parameters);
			}
		}
		DEBUG && self::log(sprintf('checking [%s, {%s}]', $command, self::array2string($parameters)));
		$retval = false;
		switch ($command)
		{
			case self::CMD_CREATE_SESSION:
				$parameters[self::PARAM_CLIENT_ID] = CLIENT_ID;
				$parameters[self::PARAM_CLIENT_VERSION] = CLIENT_VERSION;
				$retval = self::isParameterPresent(array(
					self::PARAM_KUERZEL,
					self::PARAM_PASSWORT
				), $parameters);
				break;
			case self::CMD_DROP_SESSION:
				return true;
				break;
			case self::CMD_ADD_ORDER_BOOKIT:
			case self::CMD_GET_SELECTIONINFO:
			case self::CMD_ADD_PRIVATECUSTOMER:
			case self::CMD_ADD_DETAIL_BOOKIT:
			case self::CMD_RELEASE_ORDER:
				return true;
			default:
				return false;
		}
		return $retval;
	}

	protected static function isParameterPresent($subject, $parameters)
	{
		$keys = array_keys($parameters);
		if (is_array($subject))
		{
			foreach ($subject as $parametername)
			{
				DEBUG && self::log(sprintf('is param "%s" present in {%s}', $parametername, self::array2string($parameters)));
				if (! in_array($parametername, $keys))
				{
					DEBUG && self::log("\"$parametername\" not found in " . self::array2string($parameters));
					return false;
				}
			}
			return true;
		}
		return in_array($subject, $keys);
	}

	protected static function parameter2lower(&$parameters)
	{
		foreach ($parameters as $key => $value)
		{
			$parameters[strtolower($key)] = $value;
		}
		return $parameters;
	}

	protected static function array2string($array)
	{
		if (is_array($array))
		{
			$retval = '';
			foreach ($array as $k => $v)
			{
				if (! empty($retval))
				{
					$retval .= ', ';
				}
				$retval .= "$k => $v";
			}
			return $retval;
		}
		return '';
	}

	public static function log($msg)
	{
		echo "$msg\n";
	}

	/**
	 * Replaces the special character with human readable stuff
	 */
	private static function parse($bzInput, $mode = self::PARSE_OUTPUT_MODE_TXT)
	{
		$txtMap = array(
			LINE_DELIMITER => "\n",
			PARAMETER_DELIMITER =>',',
			COMMAND_DELIMITER => "\n\n",
			COLUMN_DELIMITER => ";"
		);
		
		$htmlMap = array(
			LINE_DELIMITER => "<br>",
			PARAMETER_DELIMITER => ',',
			COMMAND_DELIMITER => "<br><br>",
			COLUMN_DELIMITER => "|"
		);
		$map = $mode == self::PARSE_OUTPUT_MODE_HTML ? $htmlMap : $txtMap;
		$input = $bzInput;
		foreach ($map as $search => $replace)
		{
			$input = str_replace($search, $replace, $input);
		}
		return $input;
	}
}